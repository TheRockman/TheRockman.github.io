<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
  </head>
  <body>
    <div class="container">
	<header>
		<div class="stats score-meter">
      <div id="score"></div>
      <label>Points</label>
		</div>
		<div class="stats move-meter">
        <div id="moves"></div>
        <label>Moves</label>
		</div>
	</header>
	<div class="board" id="board">
	</div>
      <div id="combo">COMBO!</div>
</div>	
  </body>
  <script type="text/javascript">
  "use strict";
   var _createClass = function() {
       function defineProperties(target, props) {
           for (var i = 0; i < props.length; i++) {
               var descriptor = props[i];
               descriptor.enumerable = descriptor.enumerable || false;
               descriptor.configurable = true;
               if ("value" in descriptor) descriptor.writable = true;
               Object.defineProperty(target, descriptor.key, descriptor);
           }
       }
       return function(Constructor, protoProps, staticProps) {
           if (protoProps) defineProperties(Constructor.prototype, protoProps);
           if (staticProps) defineProperties(Constructor, staticProps);
           return Constructor;
       };
   }();
 
   function _classCallCheck(instance, Constructor) {
       if (!(instance instanceof Constructor)) {
           throw new TypeError("Cannot call a class as a function");
       }
   }
   console.clear();
 
   var TOKEN = '<section>C</section>';
   var NUMBER_OF_COLUMNS = 7;
   var NUMBER_OF_ROWS = 9;
   var MAX_MOVES = 25;
   var COMBO = document.getElementById("combo");
   var Token = function() {
 
       function Token(board, type, col, row) {
           _classCallCheck(this, Token);
           this.board = board;
           this.type = type;
           this.selected = false;
           this.node = document.createElement('div');
           this.node.innerHTML = TOKEN; // + `<span class="debug-data">${col}, ${row}</span>`;
           this.gfx = this.node.querySelector('section');
           this.node.classList.add('token');
           this.node.classList.add(type);
 
           // Bind instance methods
           this.handleClick = this.handleClick.bind(this);
           this.select = this.toggleSelected.bind(this, true);
           this.deselect = this.toggleSelected.bind(this, false);
 
           this.setPosition(col, row);
           this.setupEvents();
           this.setupStyles();
       }
       _createClass(Token, [{
               key: 'toString',
               value: function toString() {
                   return this.type + '@(' + this.col + ', ' + this.row + ')';
               }
           },
           {
               key: 'attach',
               value: function attach(parent_node) {
                   parent_node.appendChild(this.node);
               }
           },
           {
               key: 'detach',
               value: function detach() {
                   this.node.remove();
               }
           },
           {
               key: 'toggleSelected',
               value: function toggleSelected(toggle) {
                   this.selected = toggle;
               }
           },
           {
               key: 'isSelected',
               value: function isSelected() {
                   return this.selected;
               }
               // Animate removal, then detach
           }, {
               key: 'remove',
               value: function remove(callback) {
                   var _this = this;
                   this.gfx.classList.add('hide');
                   setTimeout(function() {
                       _this.detach();
                       callback && callback();
                   }, 1000);
               }
           }, {
               key: 'handleClick',
               value: function handleClick()
 
               {
                   this.makeMove();
               }
           }, {
               key: 'setupStyles',
               value: function setupStyles()
 
               {
                   this.node.style.position = 'absolute';
                   this.node.style.width = Token.width + 'px';
                   this.node.style.height = Token.height + 'px';
                   this.node.style.padding = Token.padding + 'px';
                   this.node.style.transition = 'transform 0.5s';
               }
           }, {
               key: 'setupEvents',
               value: function setupEvents()
 
               {
                   this.node.addEventListener("click", this.handleClick);
               }
           }, {
               key: 'removeEvents',
               value: function removeEvents()
 
               {
                   this.node.removeEventListener("click", this.handleClick);
               }
           }, {
               key: 'setPosition',
               value: function setPosition(
 
                   x, y) {
                   // Update internal properties
                   this.col = x;
                   this.row = y;
                   // Update visual position
                   var positionX = x * Token.width;
                   var positionY = this.board.height - y * Token.height - Token.height;
                   this.node.style.transform = 'translate3d(' + positionX + 'px, ' + positionY + 'px, 0px)';
               }
           }, {
               key: 'makeMove',
               value: function makeMove()
 
 
               {
                   var _this2 = this;
 
                   function reducer(matches, token) {
                       token.select();
                       var rangedTokens = token.inRange().filter(function(token) {
                           return !!token && !token.isSelected();
                       });
                       var matchedTokens = token.matches(rangedTokens);
                       matchedTokens.forEach(function(token) {
                           return token.select();
                       });
 
                       return matchedTokens.length ?
                           matches.concat(token, matchedTokens.reduce(reducer, [])) :
                           matches.concat(token);
                   }
 
                   var matches = [this].reduce(reducer, []);
 
                   // Match self if neighbor matches are found
                   if (matches.length > 1) {
                       if (this.board.moves < MAX_MOVES) {
                           var scoreModify = matches.length;
                           if (matches.length >= 5 && matches.length < 10) {
                               COMBO.classList.add("minor-combo");
                               scoreModify = matches.length * 5;
                               setTimeout(function() {
                                   COMBO.classList.remove("minor-combo");
                               }, 3000);
                           }
                           if (matches.length >= 10) {
                               COMBO.classList.add("mega-combo");
                               scoreModify = matches.length * 10;
                               setTimeout(function() {
                                   COMBO.classList.remove("mega-combo");
                               }, 3000);
                           }
                           var score = this.board.calculateScore(scoreModify);
                           // let content = this.node.innerHTML;
                           // this.node.innerHTML = content + '<span class="scored">+' + score + '</span>';
                           this.board.score = score + this.board.score;
                           this.board.moves++;
                           this.board.displayStats();
 
                           matches.forEach(function(token) {
                               return token.remove();
                           });
                           // THIS IS ACTUALLY THE WORST CODE
                           setTimeout(function() {
                               _this2.board.removeTokens(matches);
                               _this2.board.recalc();
                               _this2.board.fill();
                           }, 1000);
                       } else {
                           this.board.showGameOver();
                       }
                   } else {
                       this.deselect();
                   }
               }
           }, {
               key: 'isInBounds',
               value: function isInBounds(_ref)
 
               {
                   var x = _ref.x,
                       y = _ref.y;
                   return x >= 0 && y >= 0 && x < NUMBER_OF_COLUMNS && y < NUMBER_OF_ROWS;
               }
           }, {
               key: 'getNeighborCoords',
               value: function getNeighborCoords()
 
               {
                   return [{
                           x: this.col,
                           y: this.row - 1
                       },
                       {
                           x: this.col,
                           y: this.row + 1
                       },
                       {
                           x: this.col - 1,
                           y: this.row
                       },
                       {
                           x: this.col + 1,
                           y: this.row
                       }
                   ];
 
               }
 
               /*
                *  Get tokens to the immediate top, bottom, left, and right
                */
           }, {
               key: 'inRange',
               value: function inRange() {
                   return this.getNeighborCoords().
                   filter(this.isInBounds).
                   map(this.board.getToken);
               }
           }, {
               key: 'matches',
               value: function matches(
 
                   tokens) {
                   var _this3 = this;
                   return tokens.filter(function(token) {
                       return token.type === _this3.type;
                   });
               }
           }
       ]);
       return Token;
   }();
   Token.width = 54;
   Token.height = 54;
   Token.padding = 6;
   var
 
 
       Board = function() {
           function Board(cols, rows) {
               _classCallCheck(this, Board);
               this.node = document.getElementById('board');
               this.scoreNode = document.getElementById('score');
               this.movesNode = document.getElementById('moves');
               this.cols = cols;
               this.rows = rows;
               this.width = Token.width * cols;
               this.height = Token.height * rows;
               this.score = 0;
               this.moves = 0;
               this.node.style.width = this.width + 'px';
               this.node.style.height = this.height + 'px';
 
               this.tokens = new Array(cols);
               // console.log(this.tokens);
               for (var i = 0; i < cols; i++) {
                   this.tokens[i] = [];
               }
               // console.log(this.tokens);
 
               // Bind instance methods
               this.recalc = this.recalc.bind(this);
               this.getToken = this.getToken.bind(this);
               this.fill = this.fill.bind(this);
           }
           _createClass(Board, [{
               key: 'add',
               value: function add(
 
                   token, col) {
                   this.tokens[col].push(token);
               }
           }, {
               key: 'removeTokens',
               value: function removeTokens(
 
                   tokens) {
                   this.tokens.forEach(function(col) {
                       for (var i = col.length - 1; i >= 0; i--) {
                           var token = col[i];
                           if (tokens.includes(token)) {
                               col.splice(i, 1);
                           }
                       }
                   });
               }
           }, {
               key: 'calculateScore',
               value: function calculateScore(
 
                   numberOfTokens) {
                   var multiplier = numberOfTokens > 5 ? Math.floor((numberOfTokens + 1) / 5) * 2 : 0;
                   return numberOfTokens + multiplier;
               }
           }, {
               key: 'displayStats',
               value: function displayStats()
 
               {
                   this.scoreNode.innerHTML = this.score;
                   this.movesNode.innerHTML = MAX_MOVES - this.moves;
               }
           }, {
               key: 'showGameOver',
               value: function showGameOver()
 
               {
                   var newGame = window.confirm('Game Over.  Would you like to play again?');
                   if (newGame) init();
               }
           }, {
               key: 'recalc',
               value: function recalc()
 
               {
                   this.tokens.forEach(function(col, x) {
                       return col.forEach(function(token, y) {
                           token.setPosition(x, y);
                       });
                   });
               }
           }, {
               key: 'fill',
               value: function fill()
 
               {
                   var _this4 = this;
                   this.tokens.forEach(function(col, x) {
                       var fillCount = _this4.rows - col.length;
                       for (var i = 0; i < fillCount; i++) {
                           var tokenType = rand(0, 3);
                           var newToken = new Token(_this4, 'token' + tokenType, x, _this4.rows + i);
                           _this4.add(newToken, x);
                           newToken.attach(_this4.node);
                       }
                   });
 
                   requestAnimationFrame(this.recalc);
               }
           }, {
               key: 'checkToken',
               value: function checkToken(
 
                   col, row, token) {
                   return token.col === col && token.row === row;
               }
           }, {
               key: 'getToken',
               value: function getToken(_ref2)
 
               {
                   var x = _ref2.x,
                       y = _ref2.y;
                   return this.tokens[x][y];
               }
           }]);
           return Board;
       }();
 
 
   var addOne = function addOne(number) {
       return number + 1;
   };
   var subtractOne = function subtractOne(number) {
       return number - 1;
   };
 
   var rand = function rand(min, max) {
       return (
           Math.floor(Math.random() * (max - (min - 1)) + min));
   };
 
 
   function init() {
       var board = new Board(NUMBER_OF_COLUMNS, NUMBER_OF_ROWS);
       board.node.innerHTML = '';
       board.fill();
   }
 
   init();
  </script>
  <style media="screen">
  * {
       box-sizing: border-box;
       position: relative;
       padding: 0px;
       margin: 0px;
  }
   body {
       background: url('https://mir-s3-cdn-cf.behance.net/project_modules/fs/063fe767504191.5b3c0d34a7616.jpg') center center fixed;
       background-repeat: no-repeat;
       background-size: cover;
       overflow-x: hidden;
       font-size: 1em;
  }
   header{
       width: 100%;
       text-align: center;
  }
   .token .debug-data .scored {
       display: block;
       position: absolute;
       width: 30px;
       top: 20px;
       left: 10px;
       background-color: rgba(255, 255, 255, 0.65);
       font-size: 2em;
  }
   .token > section{
       color: transparent!important;
       user-select: none;
       height: 40px;
       width: 40px;
  }
   .score-meter{
       position: fixed;
       right: 0;
       bottom: 0;
  }
   #score{
       background: blue;
       height: 50px;
       width: 50px;
       border-radius: 50%;
       line-height: 50px;
       color: white;
  }
   .score-meter label{
       color: white;
       position: absolute;
       top:-1rem;
       left: 0;
       right: 0;
       text-align: center;
  }
   .move-meter{
       position: fixed;
       left: 0;
       bottom: 0;
  }
   #moves{
       background: red;
       height: 50px;
       width: 50px;
       border-radius: 50%;
       line-height: 50px;
       color: white;
  }
   .move-meter label{
       color: white;
       position: absolute;
       top:-1rem;
       left: 0;
       right: 0;
       text-align: center;
  }
   .token0 > section {
       background: url('1.PNG') center center;
       background-size: contain;
  }
   .token1 > section {
       background: url('3.PNG') center center;
       background-size: contain;
  }
   .token2 > section {
       background: url('7.PNG') center center;
       background-size: contain;
  }
   .token3 > section {
       background: url('10.PNG') center center;
       background-size: contain;
  }
   .selected {
       background-color: #000;
  }
   .board {
       box-sizing: content-box;
       overflow: hidden;
       padding: 25px;
       background: rgba(255, 255, 255, 0.3);
       margin: 20px auto;
  }
   .container{
       width: 100%;
       position: fixed;
  }
   @media screen and (max-width: 768px) {
       .board{
           margin: 0 auto!important;
           padding: 0 !important;
      }
       .token{
           padding: 0!important;
      }
  }
   .hide {
       transform-origin: center;
       -webkit-animation: 1s hide;
       animation: 1s hide;
       -webkit-animation-fill-mode: forwards;
       animation-fill-mode: forwards;
  }
   @keyframes hide {
       0% {
           transform: scale(1);
      }
       2%{
           transform: scale(1.1);
      }
       4%{
           transform: scale(0.9);
      }
       20%{
           transform: scale(0.7);
           box-shadow: inset 0 0 50px #fff, inset 20px 0 80px #f0f, inset -20px 0 80px #0ff, inset 20px 0 300px #f0f, inset -20px 0 300px #0ff, 0 0 50px #fff, -10px 0 80px #f0f, 10px 0 80px #0ff;
      }
       50%{
           transform: scale(0.7);
      }
       70%{
           transform: scale(1.5);
           opacity: 1;
      }
       100% {
           transform: scale(1.3);
           opacity: 0;
      }
  }
   #combo{
       position: absolute;
       left: -100px;
       right: -100px;
       top: -100%;
       text-align: center;
       padding: 1rem;
       transform-origin: center;
       transform: rotate(5deg);
       font-size: 50px;
       color: white;
       text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
  }
   @keyframes minorCombo {
       0%{
           top: -100%;
      }
       60%{
           top: 25%;
      }
       70%{
           top: 25%;
      }
       100%{
           top: -100%;
      }
  }
   @keyframes megaCombo {
       0%{
           top: -100%;
      }
       60%{
           top: 25%;
      }
       70%{
           top: 25%;
      }
       100%{
           top: -100%;
      }
  }
   .minor-combo{
       transform-origin: center;
       -webkit-animation: 2s minorCombo;
       animation: 2s minorCombo;
       -webkit-animation-fill-mode: forwards;
       animation-fill-mode: forwards;
  }
   .mega-combo{
       transform-origin: center;
       -webkit-animation: 2s megaCombo;
       animation: 2s megaCombo;
       -webkit-animation-fill-mode: forwards;
       animation-fill-mode: forwards;
  }
  </style>
</html>
